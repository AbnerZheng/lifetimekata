# Lifetimes on Impls

When structs or enums have lifetimes on them, the way that `impl` blocks
work also changes slightly.

For example, say we want to create a struct which lets the user
skip through words. You might start off something like this:

``` rust,ignore
// First, the struct:

/// This struct keeps track of where we're up to in the string.
struct WordIterator<'s> {
    position: usize,
    string: &'s str
}

impl WordIterator {
    /// Creates a new WordIterator based on a string.
    fn new(string: &str) -> WordIterator {
        WordIterator {
            position: 0,
            string
        }
    }
    
    /// Gives the next word. `None` if there aren't any words left.
    fn next_word(&mut self) -> Option<&str> {
        let start_of_word = self.string[self.position..];
        let index_of_next_space = start_of_word.find(' ').unwrap_or(start_of_word.len());
        if start_of_word.len() != 0 {
            self.position += index_of_next_space + 1;
            Some(start_of_word[..index_of_next_space]) 
        } else {
            None
        }
    }
}

fn main() {
    let text = String::from("Twas brillig, and the slithy toves // Did gyre and gimble in the wabe: // All mimsy were the borogoves, // And the mome raths outgrabe. ");
    let mut word_iterator = WordIterator::new(&text);
    
    assert_eq!(word_iterator.next_word(), "Twas");
    assert_eq!(word_iterator.next_word(), "brillig,");
    
}
```

When defining our `WordIterator` struct, we said it requires a lifetime to be specified.
But when we then wrote the impl block, we didn't specifiy one. Rust requires that we do this.

The way we do this is by telling rust about a lifetime, and then putting that lifetime onto
our struct. Let's see how we do that:

``` rust,ignore
impl<'lifetime> for WordIterator<'lifetime> {
    // ...
}
```

It's useful to note that we've done this in two parts -- `impl<'lifetime>` defines a lifetime `'lifetime`.
It doesn't make any promises about what that lifetime is, it just says it exists.
`WordIterator<'lifetime>` then uses the lifetime we created, and says "`WordIterator` must live for `lifetime`".

Now, anywhere in the impl block, we can choose to use that lifetime:
# Exercise

Given a vector of things, return a vector of references to the first of that thing.

``` rust,ignore
# /// This struct keeps track of where we're up to in the string.
# struct WordIterator<'s> {
#     position: usize,
#     string: &'s str
# }

impl<'lifetime> WordIterator<'lifetime> {
    /// Creates a new WordIterator based on a string.
    fn new(string: &'lifetime str) -> WordIterator<'lifetime> {
        WordIterator {
            position: 0,
            string
        }
    }
    
    /// Gives the next word. `None` if there aren't any words left.
    /// NOTE: we don't want to use `'lifetime` on the `&mut self`, because then our
    /// borrow of `self` would last as long as it's contents.
    /// it's OK to use it on the result though.
    fn next_word<'borrow>(&'borrow mut self) -> Option<&'lifetime str> {
        let start_of_word = self.string[self.position..];
        let index_of_next_space = start_of_word.find(' ').unwrap_or(start_of_word.len());
        if start_of_word.len() != 0 {
            self.position += index_of_next_space + 1;
            Some(start_of_word[..index_of_next_space]) 
        } else {
            None
        }
    }
}

# fn main() {
#     let text = String::from("Twas brillig, and the slithy toves // Did gyre and gimble in the wabe: // All mimsy were the borogoves, // And the mome raths outgrabe. ");
#     let mut word_iterator = WordIterator::new(&text);
#     
#     assert_eq!(word_iterator.next_word(), "Twas");
#     assert_eq!(word_iterator.next_word(), "brillig,");
#     
# }

```
